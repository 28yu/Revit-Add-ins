<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>32x32 Icon Generator - Tools28</title>
<style>
  body { font-family: sans-serif; margin: 20px; background: #f5f5f5; }
  h1 { font-size: 18px; }
  .container { display: flex; gap: 30px; flex-wrap: wrap; }
  .editor-section { background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,.15); }
  .preview-section { background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,.15); }

  /* Zoomed canvas */
  canvas#editor {
    border: 1px solid #ccc;
    image-rendering: pixelated;
    cursor: crosshair;
  }

  /* Actual size preview */
  canvas#preview {
    border: 1px solid #ccc;
    image-rendering: pixelated;
  }
  .preview-row { display: flex; align-items: center; gap: 15px; margin: 10px 0; }
  .preview-bg-light { background: #f0f0f0; padding: 10px; display: inline-block; }
  .preview-bg-dark { background: #555; padding: 10px; display: inline-block; }
  .preview-bg-ribbon { background: #e3e6e8; padding: 8px; display: inline-flex; flex-direction: column; align-items: center; gap: 2px; font-size: 10px; color: #333; }

  .controls { margin: 15px 0; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .controls label { font-size: 13px; }
  button { padding: 6px 14px; cursor: pointer; border: 1px solid #aaa; border-radius: 4px; background: #fff; font-size: 13px; }
  button:hover { background: #e8e8e8; }
  button.primary { background: #2563eb; color: #fff; border-color: #2563eb; }
  button.primary:hover { background: #1d4ed8; }
  .color-btn { width: 28px; height: 28px; border: 2px solid #ccc; border-radius: 4px; cursor: pointer; padding: 0; }
  .color-btn.active { border-color: #2563eb; box-shadow: 0 0 0 2px rgba(37,99,235,.3); }

  .params { margin: 10px 0; display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
  .params label { font-size: 12px; color: #555; }
  .params input[type=range] { width: 80px; }
  .params input[type=number] { width: 50px; font-size: 12px; }
  .params select { font-size: 12px; }

  .presets { margin: 10px 0; }
  .presets button { font-size: 12px; padding: 4px 10px; }
</style>
</head>
<body>

<h1>Tools28 - Icon Generator (32x32)</h1>

<div class="container">
  <div class="editor-section">
    <h3>Editor (x12 zoom)</h3>
    <canvas id="editor" width="384" height="384"></canvas>

    <div class="controls">
      <label>Color:</label>
      <button class="color-btn active" data-color="#444444" style="background:#444444;" onclick="setColor(this)"></button>
      <button class="color-btn" data-color="#666666" style="background:#666666;" onclick="setColor(this)"></button>
      <button class="color-btn" data-color="#999999" style="background:#999999;" onclick="setColor(this)"></button>
      <button class="color-btn" data-color="#000000" style="background:#000000;" onclick="setColor(this)"></button>
      <button class="color-btn" data-color="#ffffff" style="background:#ffffff;" onclick="setColor(this)"></button>
      <button class="color-btn" data-color="transparent" style="background:repeating-conic-gradient(#ddd 0% 25%, #fff 0% 50%) 50%/8px 8px;" onclick="setColor(this)"></button>
      <input type="color" id="customColor" value="#444444" style="width:28px;height:28px;border:none;padding:0;cursor:pointer;" onchange="setColorValue(this.value)">
    </div>

    <div class="controls">
      <label>Tool:</label>
      <button id="toolPen" class="active" onclick="setTool('pen')">Pen</button>
      <button id="toolEraser" onclick="setTool('eraser')">Eraser</button>
      <button id="toolLine" onclick="setTool('line')">Line</button>
      <button id="toolRect" onclick="setTool('rect')">Rect</button>
      <button id="toolFillRect" onclick="setTool('fillRect')">Fill Rect</button>
      <span style="margin-left:10px;">
        <label>Size: </label>
        <input type="number" id="brushSize" value="1" min="1" max="4" onchange="brushSz=+this.value">
      </span>
    </div>

    <div class="presets">
      <label>Presets:</label>
      <button onclick="presetFilledRegion4()">Filled Region (4 squares)</button>
      <button onclick="presetFilledRegion4Small()">Filled Region (small)</button>
      <button onclick="clearCanvas()">Clear</button>
      <button onclick="undoAction()">Undo</button>
    </div>
  </div>

  <div class="preview-section">
    <h3>Preview (actual size)</h3>
    <div class="preview-row">
      <div class="preview-bg-ribbon">
        <canvas id="preview" width="32" height="32"></canvas>
        <span>32x32</span>
      </div>
      <div class="preview-bg-light">
        <canvas id="preview2" width="32" height="32"></canvas>
      </div>
      <div class="preview-bg-dark">
        <canvas id="preview3" width="32" height="32"></canvas>
      </div>
    </div>
    <div class="preview-row">
      <span style="font-size:12px;color:#888;">Ribbon simulation:</span>
    </div>
    <div style="background:#e3e6e8; display:inline-flex; padding:4px 8px; border-radius:3px; gap:12px;">
      <div style="display:flex;flex-direction:column;align-items:center;gap:1px;">
        <canvas id="previewRibbon" width="32" height="32" style="image-rendering:pixelated;"></canvas>
        <span style="font-size:10px;color:#333;">icon</span>
      </div>
    </div>

    <div style="margin-top:20px;">
      <button class="primary" onclick="downloadPNG()">Download PNG</button>
    </div>

    <div style="margin-top:15px;">
      <h4 style="font-size:13px;">Load existing icon:</h4>
      <input type="file" id="fileInput" accept="image/png" onchange="loadImage(this)">
    </div>
  </div>
</div>

<script>
const SIZE = 32;
const ZOOM = 12;
const editorCanvas = document.getElementById('editor');
const editorCtx = editorCanvas.getContext('2d');
const previewCanvases = ['preview','preview2','preview3','previewRibbon'].map(id => {
  const c = document.getElementById(id);
  return c.getContext('2d');
});

// Pixel data (RGBA)
let pixels = new Uint8ClampedArray(SIZE * SIZE * 4); // all transparent
let history = [];
let currentColor = [0x44, 0x44, 0x44, 255];
let currentTool = 'pen';
let brushSz = 1;
let isDrawing = false;
let lineStart = null;

function saveHistory() {
  history.push(new Uint8ClampedArray(pixels));
  if (history.length > 30) history.shift();
}

function undoAction() {
  if (history.length > 0) {
    pixels = history.pop();
    render();
  }
}

function setColor(btn) {
  document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  const c = btn.dataset.color;
  if (c === 'transparent') {
    currentColor = [0, 0, 0, 0];
  } else {
    const r = parseInt(c.slice(1,3),16);
    const g = parseInt(c.slice(3,5),16);
    const b2 = parseInt(c.slice(5,7),16);
    currentColor = [r, g, b2, 255];
  }
}

function setColorValue(hex) {
  document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  currentColor = [r, g, b, 255];
}

function setTool(t) {
  currentTool = t;
  document.querySelectorAll('.controls button[id^=tool]').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('tool' + t.charAt(0).toUpperCase() + t.slice(1));
  if (btn) btn.classList.add('active');
}

function setPixel(x, y, color) {
  if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;
  const i = (y * SIZE + x) * 4;
  pixels[i] = color[0];
  pixels[i+1] = color[1];
  pixels[i+2] = color[2];
  pixels[i+3] = color[3];
}

function getPixel(x, y) {
  const i = (y * SIZE + x) * 4;
  return [pixels[i], pixels[i+1], pixels[i+2], pixels[i+3]];
}

function drawPixelBrush(x, y, color) {
  for (let dy = 0; dy < brushSz; dy++) {
    for (let dx = 0; dx < brushSz; dx++) {
      setPixel(x + dx, y + dy, color);
    }
  }
}

function drawLine(x0, y0, x1, y1, color) {
  const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
  let err = dx - dy;
  while (true) {
    setPixel(x0, y0, color);
    if (x0 === x1 && y0 === y1) break;
    const e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x0 += sx; }
    if (e2 < dx) { err += dx; y0 += sy; }
  }
}

function drawRect(x0, y0, x1, y1, color, fill) {
  const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);
  const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);
  if (fill) {
    for (let y = minY; y <= maxY; y++)
      for (let x = minX; x <= maxX; x++)
        setPixel(x, y, color);
  } else {
    for (let x = minX; x <= maxX; x++) { setPixel(x, minY, color); setPixel(x, maxY, color); }
    for (let y = minY; y <= maxY; y++) { setPixel(minX, y, color); setPixel(maxX, y, color); }
  }
}

function render() {
  // Editor (zoomed)
  editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
  // Checkerboard background
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const light = (x + y) % 2 === 0;
      editorCtx.fillStyle = light ? '#ffffff' : '#e0e0e0';
      editorCtx.fillRect(x * ZOOM, y * ZOOM, ZOOM, ZOOM);
    }
  }
  // Pixels
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const [r, g, b, a] = getPixel(x, y);
      if (a > 0) {
        editorCtx.fillStyle = `rgba(${r},${g},${b},${a/255})`;
        editorCtx.fillRect(x * ZOOM, y * ZOOM, ZOOM, ZOOM);
      }
    }
  }
  // Grid
  editorCtx.strokeStyle = 'rgba(0,0,0,0.08)';
  editorCtx.lineWidth = 0.5;
  for (let i = 0; i <= SIZE; i++) {
    editorCtx.beginPath(); editorCtx.moveTo(i*ZOOM, 0); editorCtx.lineTo(i*ZOOM, SIZE*ZOOM); editorCtx.stroke();
    editorCtx.beginPath(); editorCtx.moveTo(0, i*ZOOM); editorCtx.lineTo(SIZE*ZOOM, i*ZOOM); editorCtx.stroke();
  }

  // Previews
  const imgData = new ImageData(new Uint8ClampedArray(pixels), SIZE, SIZE);
  previewCanvases.forEach(ctx => {
    ctx.clearRect(0, 0, SIZE, SIZE);
    ctx.putImageData(imgData, 0, 0);
  });
}

function getCanvasXY(e) {
  const rect = editorCanvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / ZOOM);
  const y = Math.floor((e.clientY - rect.top) / ZOOM);
  return [Math.max(0, Math.min(SIZE-1, x)), Math.max(0, Math.min(SIZE-1, y))];
}

editorCanvas.addEventListener('mousedown', e => {
  const [x, y] = getCanvasXY(e);
  const color = currentTool === 'eraser' ? [0,0,0,0] : currentColor;

  if (currentTool === 'pen' || currentTool === 'eraser') {
    saveHistory();
    isDrawing = true;
    drawPixelBrush(x, y, color);
    render();
  } else if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'fillRect') {
    saveHistory();
    isDrawing = true;
    lineStart = [x, y];
  }
});

editorCanvas.addEventListener('mousemove', e => {
  if (!isDrawing) return;
  const [x, y] = getCanvasXY(e);
  const color = currentTool === 'eraser' ? [0,0,0,0] : currentColor;

  if (currentTool === 'pen' || currentTool === 'eraser') {
    drawPixelBrush(x, y, color);
    render();
  }
});

editorCanvas.addEventListener('mouseup', e => {
  if (!isDrawing) return;
  const [x, y] = getCanvasXY(e);
  const color = currentTool === 'eraser' ? [0,0,0,0] : currentColor;

  if (currentTool === 'line') {
    drawLine(lineStart[0], lineStart[1], x, y, color);
  } else if (currentTool === 'rect') {
    drawRect(lineStart[0], lineStart[1], x, y, color, false);
  } else if (currentTool === 'fillRect') {
    drawRect(lineStart[0], lineStart[1], x, y, color, true);
  }
  isDrawing = false;
  lineStart = null;
  render();
});

editorCanvas.addEventListener('mouseleave', () => { isDrawing = false; });

function clearCanvas() {
  saveHistory();
  pixels = new Uint8ClampedArray(SIZE * SIZE * 4);
  render();
}

// Preset: Filled Region icon (4 hatched squares with padding)
function presetFilledRegion4() {
  saveHistory();
  pixels = new Uint8ClampedArray(SIZE * SIZE * 4);
  const outline = [0x55, 0x55, 0x55, 255];
  const hatch = [0x77, 0x77, 0x77, 255];

  // 4 squares: 2x2 grid, with padding
  // padding=4, gap=2, each square = 11x11
  const pad = 4;
  const gap = 2;
  const sq = 11;
  const positions = [
    [pad, pad],
    [pad + sq + gap, pad],
    [pad, pad + sq + gap],
    [pad + sq + gap, pad + sq + gap]
  ];

  positions.forEach(([sx, sy]) => {
    // Outline
    drawRect(sx, sy, sx + sq - 1, sy + sq - 1, outline, false);
    // Diagonal hatching inside
    for (let i = 1; i < sq - 1; i++) {
      for (let j = 1; j < sq - 1; j++) {
        if ((i + j) % 3 === 0) {
          setPixel(sx + j, sy + i, hatch);
        }
      }
    }
  });
  render();
}

// Preset: Smaller version
function presetFilledRegion4Small() {
  saveHistory();
  pixels = new Uint8ClampedArray(SIZE * SIZE * 4);
  const outline = [0x55, 0x55, 0x55, 255];
  const hatch = [0x77, 0x77, 0x77, 255];

  // padding=6, gap=2, each square = 8x8
  const pad = 6;
  const gap = 2;
  const sq = 8;
  const positions = [
    [pad, pad],
    [pad + sq + gap, pad],
    [pad, pad + sq + gap],
    [pad + sq + gap, pad + sq + gap]
  ];

  positions.forEach(([sx, sy]) => {
    drawRect(sx, sy, sx + sq - 1, sy + sq - 1, outline, false);
    for (let i = 1; i < sq - 1; i++) {
      for (let j = 1; j < sq - 1; j++) {
        if ((i + j) % 3 === 0) {
          setPixel(sx + j, sy + i, hatch);
        }
      }
    }
  });
  render();
}

function downloadPNG() {
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = SIZE;
  tmpCanvas.height = SIZE;
  const ctx = tmpCanvas.getContext('2d');
  const imgData = new ImageData(new Uint8ClampedArray(pixels), SIZE, SIZE);
  ctx.putImageData(imgData, 0, 0);

  const link = document.createElement('a');
  link.download = 'filled_region_32.png';
  link.href = tmpCanvas.toDataURL('image/png');
  link.click();
}

function loadImage(input) {
  const file = input.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    saveHistory();
    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = SIZE;
    tmpCanvas.height = SIZE;
    const ctx = tmpCanvas.getContext('2d');
    ctx.clearRect(0, 0, SIZE, SIZE);
    ctx.drawImage(img, 0, 0, SIZE, SIZE);
    const imgData = ctx.getImageData(0, 0, SIZE, SIZE);
    pixels = new Uint8ClampedArray(imgData.data);
    render();
  };
  img.src = URL.createObjectURL(file);
}

// Init
render();
</script>

</body>
</html>
